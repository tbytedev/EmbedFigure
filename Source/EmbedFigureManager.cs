/*
 * EmbedFigure - Visual Studio extension for embedding math figures into source code
 * Copyright(C) 2020 Tamas Kezdi
 *
 * This program is free software : you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */

#define TRACE

using MVST  = Microsoft.VisualStudio.Text;
using MVSTE = Microsoft.VisualStudio.Text.Editor;
using MVSTF = Microsoft.VisualStudio.Text.Formatting;
using SC    = System.Collections;
using SCG   = System.Collections.Generic;
using SD    = System.Drawing;
using SDI   = System.Drawing.Imaging;
using SIO   = System.IO;
using ST    = System.Timers;
using STT   = System.Threading.Tasks;
using SW    = System.Windows;
using SWC   = System.Windows.Controls;
using SWM   = System.Windows.Media;
using SWMI  = System.Windows.Media.Imaging;

#if TRACE
using TRC_SD   = System.Diagnostics;
using TRC_ST   = System.Threading;
using TRC_SRCS = System.Runtime.CompilerServices;
#endif

namespace EmbedFigure
{
	enum ColorTheme
	{
		Unspecified,
		Light,
		Dark
	}

	/// <summary>
	/// Contains the rendered figure, that is ready to add to the <see cref="Microsoft.VisualStudio.Text.Editor.IAdornmentLayer">IAdornmentLayer</see>
	/// </summary>
	internal class Figure : System.IDisposable
	{
		internal readonly SWMI.BitmapImage m_BitmapImage;
		internal readonly double m_Height;
		internal readonly double m_ZoomLevel;
		internal readonly ColorTheme m_ColorTheme;
		internal readonly bool m_Inverted;

		private readonly SIO.MemoryStream m_MemoryStream;
		private int m_ReferenceCount = 1;

		internal Figure(SIO.MemoryStream memory_stream, double height, double zoom_level, ColorTheme color_tone, bool inverted)
		{
			// Load bitmap to System.Windows.Media.Imaging.BitmapImage from System.IO.MemoryStream
			m_BitmapImage = new SWMI.BitmapImage();
			m_BitmapImage.BeginInit();
			m_BitmapImage.StreamSource = memory_stream;
			m_BitmapImage.EndInit();

			m_MemoryStream = memory_stream;
			m_Height = height;
			m_ZoomLevel = zoom_level;
			m_ColorTheme = color_tone;
			m_Inverted = inverted;
		}

		internal void IncreaseReferenceCount()
		{
			++m_ReferenceCount;
		}

		internal bool DecreaseReferenceCount()
		{
			--m_ReferenceCount;
			if (0 == m_ReferenceCount)
			{
				Dispose();
				return true;
			}
			return false;
		}

		public void Dispose()
		{
			m_MemoryStream.Dispose();
		}
	}

	internal class FigureCacheID
	{
		internal readonly string m_DictionaryPath;
		internal readonly string m_Filename;
		internal double m_ZoomLevel;
		internal bool m_Inverted;

		internal FigureCacheID(string dictionary_path, string filename, double zoom_level, bool inverted)
		{
			m_DictionaryPath = dictionary_path;
			m_Filename = filename;
			m_ZoomLevel = zoom_level;
			m_Inverted = inverted;
		}
		internal string GetFilePath()
		{
			return m_DictionaryPath + SIO.Path.DirectorySeparatorChar + m_Filename;
		}

		/// <summary>
		/// Determines whether two <see cref="FigureCacheID"/> instances are equal.
		/// </summary>
		/// <remarks>
		/// <para><see cref="FigureCacheID"/> is used as key for <see cref="System.Collections.Generic.Dictionary{TKey, TValue}">Dictionary</see>,
		/// and this override is required for comparing the key by content and not by reference.</para>
		/// <para>Comparing by reference is still possible via operator ==</para>
		/// </remarks>
		public override bool Equals(object obj)
		{
			return obj is FigureCacheID id && m_DictionaryPath == id.m_DictionaryPath && m_Filename == id.m_Filename && m_Inverted == id.m_Inverted;
		}

		/// <summary>
		/// Hash for <see cref="FigureCacheID"/>
		/// </summary>
		/// <remarks>
		/// <para><see cref="FigureCacheID"/> is used as key for <see cref="System.Collections.Generic.Dictionary{TKey, TValue}">Dictionary</see>,
		/// and this override is required for comparing the key by content and not by reference.</para>
		/// <para>Generated by Visual Studio.</para>
		/// </remarks>
		public override int GetHashCode()
		{
			int hashCode = 2138992742;
			hashCode = hashCode * -1521134295 + SCG.EqualityComparer<string>.Default.GetHashCode(m_DictionaryPath);
			hashCode = hashCode * -1521134295 + SCG.EqualityComparer<string>.Default.GetHashCode(m_Filename);
			hashCode = hashCode * -1521134295 + m_Inverted.GetHashCode();
			return hashCode;
		}
	}

	internal readonly struct FigureParams
	{
		internal readonly FigureCacheID m_FigureCacheID;
		internal readonly ColorTheme m_ColorTheme;

		internal FigureParams(FigureCacheID figure_cache_id, ColorTheme color_tone)
		{
			m_FigureCacheID = figure_cache_id;
			m_ColorTheme = color_tone;
		}
	}

	internal class FigureLoadParams
	{
		internal readonly FigureCacheID m_FigureCacheID;
		internal readonly SCG.HashSet<LineID> m_LineIDs;
		internal readonly ColorTheme m_ColorTheme;

		public FigureLoadParams(FigureCacheID figure_cache_id, SCG.HashSet<LineID> line_ids, ColorTheme color_tone)
		{
			m_FigureCacheID = figure_cache_id;
			m_LineIDs = line_ids;
			m_ColorTheme = color_tone;
		}
	}

	internal class LineEntry
	{
		internal FigureCacheID m_FigureCacheID;
		internal Figure m_Figure;
		internal ColorTheme m_ColorTheme;
		internal bool m_Added;
		internal bool m_Dirty;

		public LineEntry(FigureCacheID figure_cache_id, ColorTheme color_theme)
		{
			m_FigureCacheID = figure_cache_id;
			m_ColorTheme = color_theme;
			m_Figure = null;
			m_Added = false;
			m_Dirty = true;
		}

		internal void RemoveFigure()
		{
			if (null != m_Figure)
			{
				if (m_Figure.DecreaseReferenceCount())
				{
					EmbedFigureManager.s_FigureCache.Remove(m_FigureCacheID);
				}
				m_Figure = null;
			}
		}
	}

	internal readonly struct LineID
	{
		internal readonly EmbedFigureManager m_Manager;
		internal readonly int m_LineNumber;

		internal LineID(EmbedFigureManager manager, int line_number)
		{
			m_Manager = manager;
			m_LineNumber = line_number;
		}
	}

	enum ParameterType
	{
		UnknownParameter,
		ColorTheme,
		SVGFile,
		ParameterValue
	}

	internal readonly struct ParameterToken
	{
		internal readonly string m_RawText;
		internal readonly ParameterType m_Type;

		internal ParameterToken(string raw_text, ParameterType type)
		{
			m_RawText = raw_text;
			m_Type = type;
		}
	}

	/// <summary>
	/// TextAdornment to place figures after #EmbedFigure instructions
	/// </summary>
	internal class EmbedFigureManager
	{
		/// <summary>
		/// Stores rendered figures for each path in <see cref="System.Windows.Media.Imaging.BitmapImage">BitmapImages</see>
		/// It's accessed only from Main thread
		/// </summary>
		internal static readonly SCG.Dictionary<FigureCacheID, Figure> s_FigureCache = new SCG.Dictionary<FigureCacheID, Figure>();

		/// <summary>
		/// Instruction to embed a figure to the source. This is prefixed by a #
		/// </summary>
		private static readonly char[] s_InstructionCharArray = { 'E', 'm', 'b', 'e', 'd', 'F', 'i', 'g', 'u', 'r', 'e' };

		private static readonly ParameterToken[] s_ParameterDefinitions =
		{
			new ParameterToken("ColorTheme", ParameterType.ColorTheme),
			new ParameterToken("SVGFile", ParameterType.SVGFile)
		};

		/// <summary>
		/// List of characters, that are not allowed in file names
		/// </summary>
		private static readonly char[] s_InvalidChars;

		/// <summary>
		/// This timer is fired after the user hasn't changed the text for 1500 ms and there are files to load.
		/// </summary>
		/// <remarks>
		/// Do not load and render figures at once while user is still typing, rather wait some time to let things settle down a bit.
		/// Load is commenced when this timer is elapsed.
		/// </remarks>
		private static readonly ST.Timer s_LoadingTimer = new ST.Timer(1500);

		/// <summary>
		/// Stores the figures to load and the lines to refresh
		/// It's accessed from both Main and Timer thread
		/// </summary>
		private static readonly SCG.Dictionary<LineID, FigureParams> s_LineLoadQueue = new SCG.Dictionary<LineID, FigureParams>();

		private static readonly SCG.List<EmbedFigureManager> s_Managers = new SCG.List<EmbedFigureManager>();

		private static readonly FileWatcher s_FileWatcher = new FileWatcher();

#if TRACE
		private static readonly TRC_ST.ThreadLocal<string> s_ThreadName = new TRC_ST.ThreadLocal<string>(() => { return "Thread " + (10 > TRC_ST.Thread.CurrentThread.ManagedThreadId ? " " + TRC_ST.Thread.CurrentThread.ManagedThreadId : TRC_ST.Thread.CurrentThread.ManagedThreadId.ToString()); });
		private static readonly TRC_ST.ThreadLocal<int>    s_Indent     = new TRC_ST.ThreadLocal<int>   (() => { return 0; });
#endif

		/// <summary>
		/// Indicates if the timer is active.
		/// </summary>
		/// <remarks>
		/// <see cref="OnTimerElapsed">OnTimerElapsed</see> may be raised even after <see cref="s_LoadingTimer">s_LoadingTimer</see> has been stopped.
		/// The actual value of this ID is copied into the event handled each time the timer has been started, and this ID is incremented each time the timer has been stopped.
		/// So when the event is raised the event handler can compare its copied ID and the actual ID.
		/// If the two values are the same no Stop() method has been between the timer start and timer raise.
		/// </remarks>
		private static int s_LoadingTimerStartID = 0;

		/// <summary>
		/// Set up a sorted list of invalid characters, because it's faster to search in sorted arrays.
		/// </summary>
		static EmbedFigureManager()
		{
			var invalid_chars = new SCG.List<char>(SIO.Path.GetInvalidFileNameChars());

			// Remove those characters from invalid list which are valid in paths
			invalid_chars.Remove(SIO.Path.DirectorySeparatorChar);
			invalid_chars.Remove(SIO.Path.AltDirectorySeparatorChar);
			invalid_chars.Remove(SIO.Path.VolumeSeparatorChar);

			s_InvalidChars = invalid_chars.ToArray();
			System.Array.Sort(s_InvalidChars);

			s_FileWatcher.FileChanged += OnFileChanged;
			s_FileWatcher.FileDeleted += OnFileDeleted;

			s_LoadingTimer.AutoReset = false;
		}

		private static ColorTheme GetColorThemeFromBrush(SWM.Brush brush)
		{
			if (brush is SWM.SolidColorBrush solid_color_brush)
			{
				float luminosity = 0.2126f * solid_color_brush.Color.ScR + 0.7152f * solid_color_brush.Color.ScG + 0.0722f * solid_color_brush.Color.ScB;
				if (0.5 < luminosity)
				{
					return ColorTheme.Light;
				}
				else
				{
					return ColorTheme.Dark;
				}
			}
			return ColorTheme.Unspecified;
		}

		private static void OnFileChanged(string directory_path, string filename)
		{

		}

		private static void OnFileDeleted(string directory_path, string filename)
		{

		}

		static ST.ElapsedEventHandler s_LoadingTimerEventHandler;

		private static void StartLoadingTimer()
		{
			// Capture current value of s_LoadingTimerStartID to be used in event handler lambda expression.
			var loading_timer_start_id = s_LoadingTimerStartID;

			// Create new delegate from lambda with captured timer start ID, and store it to be able to unsubscribe later.
			s_LoadingTimerEventHandler = (sender, e) => { OnTimerElapsed(loading_timer_start_id); };

			// It's necessary to subscribe a new delegate each time the timer has been started, because every delegate contains a different captured timer start id.
			s_LoadingTimer.Elapsed += s_LoadingTimerEventHandler;
			s_LoadingTimer.Start();
		}

		private static void StopLoadingTimer()
		{
			// It's possible that Elapsed event is raised after the Stop method is called. Increasing timer start ID invalidates upcoming elapsed event.
			++s_LoadingTimerStartID;
			s_LoadingTimer.Stop();

			// Unsubscribe event handler
			if (null != s_LoadingTimerEventHandler)
			{
				s_LoadingTimer.Elapsed -= s_LoadingTimerEventHandler;
				s_LoadingTimerEventHandler = null;
			}
		}


		/// <summary>
		/// The layer of the adornment.
		/// </summary>
		private readonly MVSTE.IAdornmentLayer m_AdornmentLayer;

		/// <summary>
		/// Text document. Needed for retrieving file path.
		/// </summary>
		private readonly MVST.ITextDocument m_TextDocument;

		/// <summary>
		/// Text view where the adornment is created.
		/// </summary>
		private readonly MVSTE.IWpfTextView m_TextView;

		/// <summary>
		/// Stores figure info for each line in this manager
		/// </summary>
		internal SCG.Dictionary<int, LineEntry> m_LineFigures = new SCG.Dictionary<int, LineEntry>();

		/// <summary>
		/// Current color theme
		/// </summary>
		private ColorTheme m_ColorTheme = ColorTheme.Unspecified;

		/// <summary>
		/// Initializes a new instance of the <see cref="EmbedFigureManager"/> class.
		/// </summary>
		/// <param name="text_view">Text view to create the adornment for</param>
		internal EmbedFigureManager(MVSTE.IWpfTextView text_view, MVST.ITextDocumentFactoryService text_document_factory_service)
		{
			if (text_view == null)
			{
				throw new System.ArgumentNullException("TextView");
			}

			if (!text_document_factory_service.TryGetTextDocument(text_view.TextBuffer, out m_TextDocument))
			{
				// Document doesn't exist for textView.TextBuffer
				return;
			}

			s_Managers.Add(this);

			m_AdornmentLayer = text_view.GetAdornmentLayer("EmbedFigureAdornmentLayer");

			m_TextView = text_view;

			// Detect background color brightness
			m_ColorTheme = GetColorThemeFromBrush(m_TextView.Background);

			m_TextView.BackgroundBrushChanged += OnBackgroundChanged;
			m_TextView.Closed                 += OnClosed;
			m_TextView.LayoutChanged          += OnLayoutChanged;
			m_TextView.ZoomLevelChanged       += OnZoomLevelChanged;
		}

		private void AddAdornment(MVSTF.ITextViewLine line, int line_number, LineEntry line_entry)
		{
#if TRACE
			EnterFunction();
#endif
			MVST.SnapshotSpan span = line.Extent;
			SWM.Geometry geometry = m_TextView.TextViewLines.GetMarkerGeometry(span);
			if (null != geometry)
			{
				var image = new SWC.Image
				{
					Source = line_entry.m_Figure.m_BitmapImage,
					Height = line_entry.m_Figure.m_Height
				};

				SWC.Canvas.SetLeft(image, geometry.Bounds.Left);
				SWC.Canvas.SetTop(image, geometry.Bounds.Bottom);
				m_AdornmentLayer.AddAdornment(MVSTE.AdornmentPositioningBehavior.TextRelative, span, line_number, image, OnAdornmentRemoved);
				line_entry.m_Added = true;
			}
#if TRACE
			LeaveFunction();
#endif
		}

		private SCG.List<ParameterToken> TokenizeParameters(string parameters_string)
		{
			var tokens = new SCG.List<ParameterToken>();
			int token_start_index = 0;
			int parameters_string_lenght = parameters_string.Length;

			int current_index = 0;
			for (;;)
			{
				if ('"' == parameters_string[current_index])
				{
					// Parameter is surrounded by "s
					int text_start_index = token_start_index + 1;
					++current_index;
					if (current_index == parameters_string_lenght)
					{
						return tokens;
					}

					bool quote_escaped = false;
					string unescaped_string = null;
					for (;;)
					{
						// Look for closing "
						while ('"' != parameters_string[current_index])
						{
							++current_index;
							if (current_index == parameters_string_lenght)
							{
								if (quote_escaped)
								{
									tokens.Add(new ParameterToken(unescaped_string + parameters_string.Substring(text_start_index, current_index - text_start_index), ParameterType.ParameterValue));
								}
								else
								{
									tokens.Add(new ParameterToken(parameters_string.Substring(text_start_index, current_index - text_start_index), ParameterType.ParameterValue));
								}
								return tokens;
							}
						}

						if ('\\' != parameters_string[current_index - 1])
						{
							// This isn't a closing ", because it's escaped by the preceding \
							if (quote_escaped)
							{
								tokens.Add(new ParameterToken(unescaped_string + parameters_string.Substring(text_start_index, current_index - text_start_index), ParameterType.ParameterValue));
							}
							else
							{
								tokens.Add(new ParameterToken(parameters_string.Substring(text_start_index, current_index - text_start_index), ParameterType.ParameterValue));
							}
							break;
						}

						// We need a new string in which the escaping \s are excluded. Substring of the parameter_string can't be used.
						if (!quote_escaped)
						{
							quote_escaped = true;
							unescaped_string = parameters_string.Substring(text_start_index, current_index - text_start_index - 1);
						}
						else
						{
							unescaped_string += parameters_string.Substring(text_start_index, current_index - text_start_index - 1);
						}
						text_start_index = current_index;

						// Advance to the next character after escaped "
						++current_index;
						if (current_index == parameters_string_lenght)
						{
							if (quote_escaped)
							{
								tokens.Add(new ParameterToken(unescaped_string + parameters_string.Substring(text_start_index, current_index - text_start_index), ParameterType.ParameterValue));
							}
							else
							{
								tokens.Add(new ParameterToken(parameters_string.Substring(text_start_index, current_index - text_start_index), ParameterType.ParameterValue));
							}
							return tokens;
						}
					}

					// Advance to the next character after closing "
					++current_index;
					if (current_index == parameters_string_lenght)
					{
						return tokens;
					}

					// " must be followed by a space
					if (!char.IsWhiteSpace(parameters_string[current_index]))
					{
						return tokens;
					}

					// Skip spaces after "
					while (char.IsWhiteSpace(parameters_string[current_index]))
					{
						++current_index;
						if (current_index == parameters_string_lenght)
						{
							return tokens;
						}
					}
				}
				else
				{
					// Look for closing space or :
					while (!char.IsWhiteSpace(parameters_string[current_index]) && ':' != parameters_string[current_index])
					{
						++current_index;
						if (current_index == parameters_string_lenght)
						{
							tokens.Add(new ParameterToken(parameters_string.Substring(token_start_index, current_index - token_start_index), ParameterType.ParameterValue));
							return tokens;
						}
					}

					string parameter_name = parameters_string.Substring(token_start_index, current_index - token_start_index);

					// Skip spaces after parameter
					while (char.IsWhiteSpace(parameters_string[current_index]))
					{
						++current_index;
						if (current_index == parameters_string_lenght)
						{
							tokens.Add(new ParameterToken(parameter_name, ParameterType.ParameterValue));
							return tokens;
						}
					}

					if (':' == parameters_string[current_index])
					{
						// Parameter is followed by a :. It's a parameter name.
						// Look for supported parameters
						foreach (ParameterToken definition in s_ParameterDefinitions)
						{
							if (definition.m_RawText == parameter_name)
							{
								tokens.Add(definition);
								goto _parameter_found;
							}
						}
						tokens.Add(new ParameterToken(parameter_name, ParameterType.UnknownParameter));

					_parameter_found:

						// Advance to the next character after :
						++current_index;
						if (current_index == parameters_string_lenght)
						{
							return tokens;
						}

						// Skip spaces after :
						while (char.IsWhiteSpace(parameters_string[current_index]))
						{
							++current_index;
							if (current_index == parameters_string_lenght)
							{
								return tokens;
							}
						}
					}
					else
					{
						// Parameter isn't followed by a :. It's a parameter value
						tokens.Add(new ParameterToken(parameter_name, ParameterType.ParameterValue));
					}
				}

				token_start_index = current_index;
			}
		}

		/// <summary>
		/// Parse line. Search for #EmbedFigure instruction, and register figure changes.
		/// </summary>
		/// <param name="line">Line to add the adornments</param>
		private void ParseLine(string line_string, out string out_dictionary_path, out string out_filename, out ColorTheme out_color_tone)
		{
			out_dictionary_path = null;
			out_filename = null;
			out_color_tone = ColorTheme.Unspecified;
			int line_length = line_string.Length;

			int index_in_line;
			for (index_in_line = 0; index_in_line < line_length; ++index_in_line)
			{
			_again:
				if ('#' != line_string[index_in_line])
				{
					continue;
				}

				// '#' counts only if the previous character was not a letter or digit
				if (0 != index_in_line && char.IsLetterOrDigit(line_string[index_in_line - 1]))
				{
					continue;
				}

				++index_in_line;
				// Compare instruction
				for (int index_in_instruction = 0; index_in_instruction < s_InstructionCharArray.Length; ++index_in_instruction, ++index_in_line)
				{
					if (index_in_line == line_length)
					{
						return;
					}
					if (s_InstructionCharArray[index_in_instruction] != line_string[index_in_line])
					{
						goto _again;
					}
				}

				if (index_in_line == line_length)
				{
					return;
				}

				// Instruction must be followed by a whitespace
				if (!char.IsWhiteSpace(line_string[index_in_line]))
				{
					goto _again;
				}

				// Skip spaces between instruction and first parameter
				do
				{
					++index_in_line;
					if (index_in_line == line_length)
					{
						return;
					}
				}
				while (char.IsWhiteSpace(line_string[index_in_line]));

				SCG.List<ParameterToken> tokens = TokenizeParameters(line_string.Substring(index_in_line));

				ParameterType parameter_name = ParameterType.UnknownParameter;

				string local_path = null;

				foreach (ParameterToken token in tokens)
				{
					if (token.m_Type == ParameterType.ParameterValue)
					{
						switch (parameter_name)
						{
							case ParameterType.SVGFile:
								if (null == local_path)
								{
									if (0 == token.m_RawText.Length)
									{
										break;
									}

									// Local path mustn't contain invalid characters
									foreach (char c in token.m_RawText)
									{
										if (0 <= System.Array.BinarySearch(s_InvalidChars, c))
										{
											goto _invalid_local_path;
										}
									}

									char last_char = token.m_RawText[token.m_RawText.Length - 1];
									if (SIO.Path.DirectorySeparatorChar == last_char || SIO.Path.AltDirectorySeparatorChar == last_char)
									{
										// Last character is a directory separator. It can't be a filename, it's a directory.
										break;
									}

									local_path = token.m_RawText;
								}
							_invalid_local_path:
								break;
							case ParameterType.ColorTheme:
								if (ColorTheme.Unspecified == out_color_tone)
								{
									if ("dark" == token.m_RawText)
									{
										out_color_tone = ColorTheme.Dark;
									}
									else if ("light" == token.m_RawText)
									{
										out_color_tone = ColorTheme.Light;
									}
								}
								break;
						}
						parameter_name = ParameterType.UnknownParameter;
					}
					else
					{
						parameter_name = token.m_Type;
					}
				}

				if (null == local_path)
				{
					return;
				}
				// TODO: Check if file system is case sensitive.
				// For now we're assuming that it's a windows file system, so it's case insensitive.
				// Convert filename to lowercase to ignore character case.
				local_path = local_path.ToLowerInvariant();
				local_path = local_path.Replace(SIO.Path.AltDirectorySeparatorChar, SIO.Path.DirectorySeparatorChar);

				// TODO: Support for full path and other rooted path types
				string figure_path = SIO.Path.GetDirectoryName(m_TextDocument.FilePath) + SIO.Path.DirectorySeparatorChar + local_path;
				out_dictionary_path = SIO.Path.GetDirectoryName(figure_path);
				out_filename = SIO.Path.GetFileName(figure_path);
				return;
			}
		}

		/// <summary>
		/// Parse line. Search for #EmbedFigure instruction, and register figure changes.
		/// </summary>
		/// <param name="line">Line to add the adornments</param>
		private void ProcessLine(MVSTF.ITextViewLine line)
		{

			MVST.ITextSnapshot text_snapshot = m_TextView.TextSnapshot;
			ParseLine(text_snapshot.GetText(line.Extent.Span), out string dictionary_path, out string filename, out ColorTheme color_theme);

			//MVSTE.IWpfTextViewLineCollection text_view_lines = m_TextView.TextViewLines;
			int line_number = text_snapshot.GetLineNumberFromPosition(line.Start);
			var line_id = new LineID(this, line_number);

			if (null == dictionary_path)
			{
				// Currently there's no figure specified in this line
				if (m_LineFigures.TryGetValue(line_number, out LineEntry old_line_entry))
				{
					// But there was a figure in this line previously. Remove previous figure.
					lock ((s_LineLoadQueue as SC.ICollection).SyncRoot)
					{
						s_LineLoadQueue.Remove(line_id);
					}

					s_FileWatcher.RemoveFile(old_line_entry.m_FigureCacheID.m_DictionaryPath, old_line_entry.m_FigureCacheID.m_Filename);
					old_line_entry.RemoveFigure();
					m_LineFigures.Remove(line_number);
				}
			}
			else
			{
				// There's a figure in this line
				double zoom_level = m_TextView.ZoomLevel;
				bool inverted = ColorTheme.Unspecified != color_theme && color_theme != m_ColorTheme;

				if (m_LineFigures.TryGetValue(line_number, out LineEntry line_entry))
				{
					// There's a figure in this line and there was a figure in this line previously
					line_entry.m_ColorTheme = color_theme;

					if (line_entry.m_FigureCacheID.m_DictionaryPath != dictionary_path ||
						line_entry.m_FigureCacheID.m_Filename       != filename ||
						line_entry.m_FigureCacheID.m_Inverted       != inverted ||
						line_entry.m_FigureCacheID.m_ZoomLevel      != zoom_level)
					{
						// The current and the previous figures are different
						line_entry.RemoveFigure();

						if (line_entry.m_FigureCacheID.m_DictionaryPath != dictionary_path || line_entry.m_FigureCacheID.m_Filename != filename)
						{
							s_FileWatcher.RemoveFile(line_entry.m_FigureCacheID.m_DictionaryPath, line_entry.m_FigureCacheID.m_Filename);
							s_FileWatcher.AddFile(dictionary_path, filename);
						}

						FigureCacheID figure_cache_id = new FigureCacheID(dictionary_path, filename, zoom_level, inverted);
						line_entry.m_FigureCacheID = figure_cache_id;

						if (s_FigureCache.TryGetValue(figure_cache_id, out Figure figure) && figure.m_ZoomLevel == m_TextView.ZoomLevel)
						{
							// This figure is already loaded, so just use it.
							figure.IncreaseReferenceCount();
							line_entry.m_Figure = figure;
							AddAdornment(line, line_number, line_entry);
						}
						else
						{
							lock ((s_LineLoadQueue as SC.ICollection).SyncRoot)
							{
								s_LineLoadQueue[line_id] = new FigureParams(figure_cache_id, color_theme);
							}
						}
					}
					else if (null != line_entry.m_Figure && !line_entry.m_Added)
					{
						AddAdornment(line, line_number, line_entry);
					}
				}
				else
				{
					// There's a figure in this line and there was no figure in this line previously
					s_FileWatcher.AddFile(dictionary_path, filename);

					FigureCacheID figure_cache_id = new FigureCacheID(dictionary_path, filename, zoom_level, inverted);
					line_entry = new LineEntry(figure_cache_id, color_theme);
					m_LineFigures[line_number] = line_entry;
					if (s_FigureCache.TryGetValue(figure_cache_id, out Figure figure))
					{
						line_entry.m_Figure = figure;
						AddAdornment(line, line_number, line_entry);
					}
					else
					{
						lock ((s_LineLoadQueue as SC.ICollection).SyncRoot)
						{
							s_LineLoadQueue.Add(line_id, new FigureParams(figure_cache_id, color_theme));
						}
					}
				}
			}
		}

		private void OnAdornmentRemoved(object tag, SW.UIElement element)
		{
#if TRACE
			EnterFunction();
#endif
			int line_number = (int)tag;
			m_LineFigures[line_number].m_Added = false;
#if TRACE
			LeaveFunction();
#endif
		}

		private void OnBackgroundChanged(object sender, MVSTE.BackgroundBrushChangedEventArgs e)
		{
			ColorTheme color_theme = GetColorThemeFromBrush(e.NewBackgroundBrush);
			if (color_theme == m_ColorTheme)
			{
				return;
			}
#if TRACE
			EnterFunction();
#endif
			m_ColorTheme = color_theme;

			lock ((s_LineLoadQueue as SC.ICollection).SyncRoot)
			{
				StopLoadingTimer();

				var line_ids_to_remove = new SCG.List<LineID>();
				foreach (SCG.KeyValuePair<LineID, FigureParams> pair in s_LineLoadQueue)
				{
					LineID line_id = pair.Key;
					FigureParams figure_params = pair.Value;
					bool inverted = ColorTheme.Unspecified != figure_params.m_ColorTheme && figure_params.m_ColorTheme != m_ColorTheme;
					if (this == line_id.m_Manager && figure_params.m_FigureCacheID.m_Inverted != inverted)
					{
						line_ids_to_remove.Add(line_id);
					}
				}
				foreach (LineID line_id in line_ids_to_remove)
				{
					s_LineLoadQueue.Remove(line_id);
				}

				foreach (SCG.KeyValuePair<int, LineEntry> pair in m_LineFigures)
				{
					LineEntry line_entry = pair.Value;
					int line_number = pair.Key;
					// If color theme is unspecified, leave the figure as it is
					if (ColorTheme.Unspecified == line_entry.m_ColorTheme)
					{
						continue;
					}
					if (line_entry.m_Added)
					{
						m_AdornmentLayer.RemoveAdornmentsByTag(line_number);
					}
					line_entry.m_FigureCacheID.m_Inverted = line_entry.m_ColorTheme != m_ColorTheme;
					s_LineLoadQueue.Add(new LineID(this, line_number), new FigureParams(line_entry.m_FigureCacheID, color_theme));
					line_entry.RemoveFigure();
				}

				if (0 < s_LineLoadQueue.Count)
				{
					StartLoadingTimer();
				}
			}
#if TRACE
			LeaveFunction();
#endif
		}

		private void OnClosed(object sender, System.EventArgs e)
		{
			m_TextView.Properties.RemoveProperty(typeof(EmbedFigureManager));
			s_Managers.Remove(this);
		}


		/// <summary>
		/// Handles whenever the text displayed in the view changes by adding the adornment to any reformatted lines
		/// </summary>
		/// <remarks><para>This event is raised whenever the rendered text displayed in the <see cref="Microsoft.VisualStudio.Text.Editor.ITextView">ITextView</see> changes.</para>
		/// <para>It is raised whenever the view does a layout (which happens when
		/// <see cref="Microsoft.VisualStudio.Text.Editor.ITextView.DisplayTextLineContainingBufferPosition">DisplayTextLineContainingBufferPosition</see> is called
		/// or in response to text or classification changes).</para>
		/// <para>It is also raised whenever the view scrolls horizontally or when its size changes.</para>
		/// <para>This function is called by the framework on Main Thread</para>
		/// </remarks>
		/// <param name="sender">The event sender.</param>
		/// <param name="e">The event arguments.</param>
		private void OnLayoutChanged(object sender, MVSTE.TextViewLayoutChangedEventArgs e)
		{
			if (0 == e.NewOrReformattedLines.Count)
			{
				return;
			}
#if TRACE
			EnterFunction();
#endif
			lock ((s_LineLoadQueue as SC.ICollection).SyncRoot)
			{
				StopLoadingTimer();
			}

			foreach (MVSTF.ITextViewLine line in e.NewOrReformattedLines)
			{
				ProcessLine(line);
			}

			lock ((s_LineLoadQueue as SC.ICollection).SyncRoot)
			{
				if (0 < s_LineLoadQueue.Count)
				{
					StartLoadingTimer();
				}
			}
#if TRACE
			LeaveFunction();
#endif
		}

		public static void LoadFigure(object context)
		{
			var figure_load_params = (FigureLoadParams)context;
			string figure_path = figure_load_params.m_FigureCacheID.GetFilePath();
			if (!SIO.File.Exists(figure_path))
			{
				return;
			}

#if TRACE
			EnterFunction();
#endif
			SD.Bitmap bitmap = null;
			SIO.MemoryStream memory_stream = null;
			double height = 0.0;
			try
			{
				Svg.SvgDocument svg_doc = Svg.SvgDocument.Open(figure_path);
				bitmap = svg_doc.Draw();
				height = bitmap.Height;
				if (100.0 != figure_load_params.m_FigureCacheID.m_ZoomLevel)
				{
					double zoom = figure_load_params.m_FigureCacheID.m_ZoomLevel / 100.0;
					bitmap = svg_doc.Draw(System.Convert.ToInt32(bitmap.Width * zoom), System.Convert.ToInt32(bitmap.Height * zoom));
				}

				// Invert figure if needed
				if (figure_load_params.m_FigureCacheID.m_Inverted)
				{
					for (int x = 0; x < bitmap.Width; ++x)
					{
						for (int y = 0; y < bitmap.Height; ++y)
						{
							SD.Color original_color = bitmap.GetPixel(x, y);
							SD.Color new_color = SD.Color.FromArgb(original_color.A, 255 - original_color.R, 255 - original_color.G, 255 - original_color.B);
							bitmap.SetPixel(x, y, new_color);
						}
					}
				}

				// Convert System.Drawing.Bitmap to System.Windows.Controls.Image, that can be added to m_AdornmentLayer
				// Save System.Drawing.Bitmap to a System.IO.MemoryStream
				memory_stream = new SIO.MemoryStream();
				bitmap.Save(memory_stream, SDI.ImageFormat.Tiff);
				memory_stream.Seek(0, SIO.SeekOrigin.Begin);

#if TRACE
				TraceMsg("Switch to Main LoadFigure");
#endif
				// UI related objects (System.Windows.Media.Imaging.BitmapImage) can be created and used only on Main thread
				Microsoft.VisualStudio.Shell.ThreadHelper.JoinableTaskFactory.Run(async delegate
				{
					await Microsoft.VisualStudio.Shell.ThreadHelper.JoinableTaskFactory.SwitchToMainThreadAsync();

#if TRACE
					TraceMsg("Switched to Main LoadFigure");
#endif
					var figure = new Figure(memory_stream, height, figure_load_params.m_FigureCacheID.m_ZoomLevel, figure_load_params.m_ColorTheme, figure_load_params.m_FigureCacheID.m_Inverted);

					s_FigureCache.Add(figure_load_params.m_FigureCacheID, figure);

					foreach (EmbedFigureManager manager in s_Managers)
					{
						foreach (SCG.KeyValuePair<int, LineEntry> pair in manager.m_LineFigures)
						{
							LineEntry line_entry = pair.Value;
							int line_number = pair.Key;
							if (line_entry.m_FigureCacheID == figure_load_params.m_FigureCacheID)
							{
								line_entry.m_Figure = figure;
								MVSTE.IWpfTextView text_view = manager.m_TextView;

								// Get the first line from text_view.TextViewLines, this is not the same as text_view.TextViewLines.FirstVisibleLine.
								// It's possible that text_view.TextViewLines[0] is hidden and it's before text_view.TextViewLines.FirstVisibleLine
								MVSTF.IWpfTextViewLine first_view_line = text_view.TextViewLines[0];
								int first_view_line_number = text_view.TextSnapshot.GetLineNumberFromPosition(first_view_line.Start);
								int view_line_number = line_number - first_view_line_number;

								// Skip lines that has no corresponding line in text_view.TextViewLines
								if (0 > view_line_number)
								{
									continue;
								}
								if (manager.m_TextView.TextViewLines.Count <= view_line_number)
								{
									continue;
								}

								// Refresh line
								MVSTF.IWpfTextViewLine curr_view_line = manager.m_TextView.TextViewLines[view_line_number];
								manager.AddAdornment(curr_view_line, line_number, line_entry);
								// Forces the call of GetLineTransform for this line
								manager.m_TextView.DisplayTextLineContainingBufferPosition(curr_view_line.Start, curr_view_line.Top - text_view.ViewportTop, MVSTE.ViewRelativePosition.Top);
							}
						}
					}
#if TRACE
					TraceMsg("Switch from Main LoadFigure");
#endif
				});
			}
			catch
			{}
			finally
			{
				bitmap?.Dispose();
			}

#if TRACE
			LeaveFunction();
#endif
			return;
		}

		/// <summary>
		/// This timer is fired after the user hasn't changed the text for 1500 ms and there are files to load.
		/// </summary>
		/// <remarks>This function is called by the framework on a Worker Thread</remarks>
		private static void OnTimerElapsed(int timer_start_id)
		{
			SCG.Dictionary<FigureParams, SCG.HashSet<LineID>> figure_load_queue;
			lock ((s_LineLoadQueue as SC.ICollection).SyncRoot)
			{
				if (s_LoadingTimerStartID != timer_start_id)
				{
					// The timer had been stopped just before this event was raised. Skip this event.
					return;
				}

#if TRACE
				EnterFunction();
#endif
				// Create a list of lines for each figure. It's possible that more than one lines are waiting for the same figure to be loaded.
				figure_load_queue = new SCG.Dictionary<FigureParams, SCG.HashSet<LineID>>();
				foreach (SCG.KeyValuePair<LineID, FigureParams> pair in s_LineLoadQueue)
				{
					FigureParams figure_params = pair.Value;
					LineID line_id = pair.Key;
					if (figure_load_queue.TryGetValue(figure_params, out SCG.HashSet<LineID> line_ids))
					{
						line_ids.Add(line_id);
					}
					else
					{
						line_ids = new SCG.HashSet<LineID> { line_id };
						figure_load_queue.Add(figure_params, line_ids);
					}
				}
				s_LineLoadQueue.Clear();
			}

			// Iterate through figures, and try to load them. Create a list of those lines that can be refreshed after their figures have been loaded.
			// s_LineLoadQueue can't be locked, because Figure.GenerateImage switches back to Main thread, and if Main is currently waiting for s_LineLoadQueue, there will be a deadlock
			foreach (SCG.KeyValuePair<FigureParams, SCG.HashSet<LineID>> pair in figure_load_queue)
			{
				FigureParams figure_params = pair.Key;

				var task = new STT.Task(LoadFigure, new FigureLoadParams(figure_params.m_FigureCacheID, pair.Value, figure_params.m_ColorTheme));
				task.Start();
				// Although System.Threading.Tasks.Task is IDisposable, it's not necessary to call its Dispose() function.
				// https://devblogs.microsoft.com/pfxteam/do-i-need-to-dispose-of-tasks/
			}
#if TRACE
			LeaveFunction();
#endif
		}

		/// <summary>Called when zoom is changed</summary>
		/// <remarks>This function is called by the framework on the MainThread</remarks>
		private void OnZoomLevelChanged(object sender, MVSTE.ZoomLevelChangedEventArgs e)
		{
#if TRACE
			EnterFunction();
#endif
			lock ((s_LineLoadQueue as SC.ICollection).SyncRoot)
			{
				StopLoadingTimer();

				var line_ids_to_remove = new SCG.List<LineID>();
				foreach (SCG.KeyValuePair<LineID, FigureParams> pair in s_LineLoadQueue)
				{
					LineID line_id = pair.Key;
					FigureParams figure_params = pair.Value;
					if (this == line_id.m_Manager && figure_params.m_FigureCacheID.m_ZoomLevel != m_TextView.ZoomLevel)
					{
						line_ids_to_remove.Add(line_id);
					}
				}
				foreach (LineID line_id in line_ids_to_remove)
				{
					s_LineLoadQueue.Remove(line_id);
				}

				foreach (SCG.KeyValuePair<int, LineEntry> pair in m_LineFigures)
				{
					LineEntry line_entry = pair.Value;
					int line_number = pair.Key;
					if (line_entry.m_Added)
					{
						m_AdornmentLayer.RemoveAdornmentsByTag(line_number);
					}
					line_entry.m_FigureCacheID.m_ZoomLevel = m_TextView.ZoomLevel;
					s_LineLoadQueue[new LineID(this, line_number)] = new FigureParams(line_entry.m_FigureCacheID, line_entry.m_ColorTheme);
					line_entry.RemoveFigure();
				}
				if (0 < s_LineLoadQueue.Count)
				{
					StartLoadingTimer();
				}
			}
#if TRACE
			LeaveFunction();
#endif
		}

#if TRACE
		internal static void TraceMsg(string message)
		{
			TRC_SD.Trace.Write("==== " + s_ThreadName.Value + " ");
			for (int i = 0; i < s_Indent.Value; ++i)
			{
				TRC_SD.Trace.Write(" ");
			}
			TRC_SD.Trace.WriteLine(message);
		}

		internal static void EnterFunction([TRC_SRCS.CallerMemberName] string function_name = "")
		{
			TraceMsg("Enter: " + function_name);
			s_Indent.Value += 2;
		}

		internal static void LeaveFunction([TRC_SRCS.CallerMemberName] string function_name = "")
		{
			s_Indent.Value -= 2;
			TraceMsg("Leave: " + function_name);
		}
#endif
	}

	/// <summary>
	/// Makes space for the adornment underneath the line
	/// </summary>
	internal class EmbedFigureLineTransformSource : MVSTF.ILineTransformSource
	{
		private readonly EmbedFigureManager m_Adornment;

		internal EmbedFigureLineTransformSource(EmbedFigureManager adornment)
		{
			m_Adornment = adornment;
		}

		/// <summary>
		/// Calculates the space needed at bottom of the line for the figure.
		/// </summary>
		/// <remarks>
		/// This function is called by the framework.
		/// </remarks>
		/// <param name="line">The line for which to calculate the line transform.</param>
		/// <param name="y_position">The y-coordinate of the line.</param>
		/// <param name="placement">The placement of the line with respect to y_position.</param>
		public MVSTF.LineTransform GetLineTransform(MVSTF.ITextViewLine line, double y_position, MVSTE.ViewRelativePosition placement)
		{
#if TRACE
			EmbedFigureManager.EnterFunction();
#endif

			MVSTF.LineTransform clt = line.LineTransform;
			MVSTF.LineTransform dlt = line.DefaultLineTransform;
			int line_number = line.Snapshot.GetLineNumberFromPosition(line.Start);

			double figure_height = 0.0;
			if (m_Adornment.m_LineFigures.TryGetValue(line_number, out LineEntry line_entry))
			{
				if (null != line_entry.m_Figure && line_entry.m_Added)
				{
					figure_height = line_entry.m_Figure.m_Height;
				}
			}

#if TRACE
			EmbedFigureManager.LeaveFunction();
#endif

			return new MVSTF.LineTransform(clt.TopSpace, dlt.BottomSpace + figure_height, clt.VerticalScale);
		}
	}
}
